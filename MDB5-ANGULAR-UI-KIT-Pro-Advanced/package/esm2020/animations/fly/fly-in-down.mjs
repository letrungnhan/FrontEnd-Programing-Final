import { animate, keyframes, style, transition, trigger, animation, useAnimation, } from '@angular/animations';
import { getOptions } from '../animations.utils';
const flyInDownOptions = {
    trigger: 'flyInDown',
    delay: 0,
    duration: 500,
};
const flyInDownEnterOptions = {
    trigger: 'flyInDownEnter',
    delay: 0,
    duration: 500,
};
const flyInDown = (options) => {
    const params = {
        delay: options.delay,
        duration: options.duration,
    };
    return animation([
        animate('{{duration}}ms {{delay}}ms', keyframes([
            style({
                opacity: 0,
                transform: 'translate3d(0, -1500px, 0)',
                easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
                offset: 0,
            }),
            style({
                opacity: 1,
                transform: 'translate3d(0, 25px, 0)',
                easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
                offset: 0.6,
            }),
            style({
                transform: 'transform: translate3d(0, -10px, 0)',
                easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
                offset: 0.75,
            }),
            style({
                transform: 'transform: translate3d(0, 5px, 0)',
                easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
                offset: 0.9,
            }),
            style({
                transform: 'transform: translate3d(0, 0, 0)',
                easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
                offset: 1,
            }),
        ])),
    ], { params });
};
export function flyInDownAnimation(options) {
    options = getOptions(options, flyInDownOptions);
    return trigger(options.trigger, [transition('0 => 1', [useAnimation(flyInDown(options))])]);
}
export function flyInDownEnterAnimation(options) {
    options = getOptions(options, flyInDownEnterOptions);
    return trigger(options.trigger, [transition(':enter', [useAnimation(flyInDown(options))])]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmx5LWluLWRvd24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9tZGItYW5ndWxhci11aS1raXQvYW5pbWF0aW9ucy9mbHkvZmx5LWluLWRvd24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLE9BQU8sRUFFUCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFVBQVUsRUFDVixPQUFPLEVBQ1AsU0FBUyxFQUNULFlBQVksR0FFYixNQUFNLHFCQUFxQixDQUFDO0FBRTdCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVqRCxNQUFNLGdCQUFnQixHQUF3QjtJQUM1QyxPQUFPLEVBQUUsV0FBVztJQUNwQixLQUFLLEVBQUUsQ0FBQztJQUNSLFFBQVEsRUFBRSxHQUFHO0NBQ2QsQ0FBQztBQUVGLE1BQU0scUJBQXFCLEdBQXdCO0lBQ2pELE9BQU8sRUFBRSxnQkFBZ0I7SUFDekIsS0FBSyxFQUFFLENBQUM7SUFDUixRQUFRLEVBQUUsR0FBRztDQUNkLENBQUM7QUFFRixNQUFNLFNBQVMsR0FBRyxDQUFDLE9BQTRCLEVBQThCLEVBQUU7SUFDN0UsTUFBTSxNQUFNLEdBQUc7UUFDYixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7UUFDcEIsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFRO0tBQzNCLENBQUM7SUFFRixPQUFPLFNBQVMsQ0FDZDtRQUNFLE9BQU8sQ0FDTCw0QkFBNEIsRUFDNUIsU0FBUyxDQUFDO1lBQ1IsS0FBSyxDQUFDO2dCQUNKLE9BQU8sRUFBRSxDQUFDO2dCQUNWLFNBQVMsRUFBRSw0QkFBNEI7Z0JBQ3ZDLE1BQU0sRUFBRSxxQ0FBcUM7Z0JBQzdDLE1BQU0sRUFBRSxDQUFDO2FBQ1YsQ0FBQztZQUNGLEtBQUssQ0FBQztnQkFDSixPQUFPLEVBQUUsQ0FBQztnQkFDVixTQUFTLEVBQUUseUJBQXlCO2dCQUNwQyxNQUFNLEVBQUUscUNBQXFDO2dCQUM3QyxNQUFNLEVBQUUsR0FBRzthQUNaLENBQUM7WUFDRixLQUFLLENBQUM7Z0JBQ0osU0FBUyxFQUFFLHFDQUFxQztnQkFDaEQsTUFBTSxFQUFFLHFDQUFxQztnQkFDN0MsTUFBTSxFQUFFLElBQUk7YUFDYixDQUFDO1lBQ0YsS0FBSyxDQUFDO2dCQUNKLFNBQVMsRUFBRSxtQ0FBbUM7Z0JBQzlDLE1BQU0sRUFBRSxxQ0FBcUM7Z0JBQzdDLE1BQU0sRUFBRSxHQUFHO2FBQ1osQ0FBQztZQUNGLEtBQUssQ0FBQztnQkFDSixTQUFTLEVBQUUsaUNBQWlDO2dCQUM1QyxNQUFNLEVBQUUscUNBQXFDO2dCQUM3QyxNQUFNLEVBQUUsQ0FBQzthQUNWLENBQUM7U0FDSCxDQUFDLENBQ0g7S0FDRixFQUNELEVBQUUsTUFBTSxFQUFFLENBQ1gsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxPQUE2QjtJQUM5RCxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBRWhELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUYsQ0FBQztBQUVELE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxPQUE2QjtJQUNuRSxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBRXJELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGFuaW1hdGUsXG4gIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSxcbiAga2V5ZnJhbWVzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvbixcbiAgdHJpZ2dlcixcbiAgYW5pbWF0aW9uLFxuICB1c2VBbmltYXRpb24sXG4gIEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLFxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IE1kYkFuaW1hdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9hbmltYXRpb24ub3B0aW9ucyc7XG5pbXBvcnQgeyBnZXRPcHRpb25zIH0gZnJvbSAnLi4vYW5pbWF0aW9ucy51dGlscyc7XG5cbmNvbnN0IGZseUluRG93bk9wdGlvbnM6IE1kYkFuaW1hdGlvbk9wdGlvbnMgPSB7XG4gIHRyaWdnZXI6ICdmbHlJbkRvd24nLFxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDUwMCxcbn07XG5cbmNvbnN0IGZseUluRG93bkVudGVyT3B0aW9uczogTWRiQW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgdHJpZ2dlcjogJ2ZseUluRG93bkVudGVyJyxcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiA1MDAsXG59O1xuXG5jb25zdCBmbHlJbkRvd24gPSAob3B0aW9uczogTWRiQW5pbWF0aW9uT3B0aW9ucyk6IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhID0+IHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIGRlbGF5OiBvcHRpb25zLmRlbGF5LFxuICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICB9O1xuXG4gIHJldHVybiBhbmltYXRpb24oXG4gICAgW1xuICAgICAgYW5pbWF0ZShcbiAgICAgICAgJ3t7ZHVyYXRpb259fW1zIHt7ZGVsYXl9fW1zJyxcbiAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgLTE1MDBweCwgMCknLFxuICAgICAgICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSknLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAyNXB4LCAwKScsXG4gICAgICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKScsXG4gICAgICAgICAgICBvZmZzZXQ6IDAuNixcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0xMHB4LCAwKScsXG4gICAgICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKScsXG4gICAgICAgICAgICBvZmZzZXQ6IDAuNzUsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCA1cHgsIDApJyxcbiAgICAgICAgICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpJyxcbiAgICAgICAgICAgIG9mZnNldDogMC45LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSknLFxuICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICBdLFxuICAgIHsgcGFyYW1zIH1cbiAgKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHlJbkRvd25BbmltYXRpb24ob3B0aW9ucz86IE1kYkFuaW1hdGlvbk9wdGlvbnMpOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEge1xuICBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zLCBmbHlJbkRvd25PcHRpb25zKTtcblxuICByZXR1cm4gdHJpZ2dlcihvcHRpb25zLnRyaWdnZXIsIFt0cmFuc2l0aW9uKCcwID0+IDEnLCBbdXNlQW5pbWF0aW9uKGZseUluRG93bihvcHRpb25zKSldKV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx5SW5Eb3duRW50ZXJBbmltYXRpb24ob3B0aW9ucz86IE1kYkFuaW1hdGlvbk9wdGlvbnMpOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEge1xuICBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zLCBmbHlJbkRvd25FbnRlck9wdGlvbnMpO1xuXG4gIHJldHVybiB0cmlnZ2VyKG9wdGlvbnMudHJpZ2dlciwgW3RyYW5zaXRpb24oJzplbnRlcicsIFt1c2VBbmltYXRpb24oZmx5SW5Eb3duKG9wdGlvbnMpKV0pXSk7XG59XG4iXX0=